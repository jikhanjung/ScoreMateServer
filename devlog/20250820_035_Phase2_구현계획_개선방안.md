# Phase 2 구현 계획 개선방안

**날짜**: 2025년 8월 20일  
**문서 번호**: 035  
**작성자**: Claude Code  
**참조 문서**: 034 (Phase 2 세트리스트 관리 기능 구현 상세 계획)  
**목적**: 문서 034의 구현 계획을 검토하고 실무 관점에서의 개선사항 제안

---

## 요약

문서 034의 Phase 2 계획은 전반적으로 잘 구성되어 있으나, Custom Hook의 책임 분리, 타입 정의 우선순위, UX 일관성 등 몇 가지 개선이 필요합니다. 특히 Phase 1에서 확립한 아키텍처 패턴과의 일관성을 유지하면서도 세트리스트 기능의 복잡성을 효과적으로 관리할 수 있는 방향으로 조정이 필요합니다.

---

## 1. Hook 아키텍처 개선방안

### 1.1 현재 계획의 문제점

**기존 설계**:
```typescript
// 문서 034 계획
useSetlists()        // 세트리스트 목록 + CRUD
useSetlistDetail()   // 세트리스트 상세 + 아이템 관리 + 순서 변경
```

**문제점**:
- `useSetlistDetail`에 너무 많은 책임 집중 (단일 책임 원칙 위반)
- 아이템 관리와 세트리스트 정보 관리가 혼재
- 테스트 및 디버깅 복잡도 증가

### 1.2 개선된 Hook 아키텍처

```typescript
// 관심사별 분리된 Hook 설계
useSetlists()        // 세트리스트 목록 CRUD만
useSetlistDetail()   // 세트리스트 기본 정보만 (제목, 설명, 메타데이터)
useSetlistItems()    // 아이템 CRUD + 순서 변경
useScoreLibrary()    // 악보 검색/선택 (모달용)
```

**장점**:
- 각 Hook의 책임이 명확히 분리
- Phase 1의 `useScores`, `useFileUpload` 패턴과 일관성 유지
- 개별 Hook 단위 테스트 용이
- 재사용성 향상 (예: `useScoreLibrary`는 다른 기능에서도 활용 가능)

### 1.3 Hook별 상세 설계

#### useSetlists Hook
```typescript
// /hooks/useSetlists.ts
interface UseSetlistsReturn {
  // State
  setlists: Setlist[];
  isLoading: boolean;
  error: string | null;
  
  // Actions
  createSetlist: (data: SetlistCreateRequest) => Promise<void>;
  updateSetlist: (id: string, data: SetlistUpdateRequest) => Promise<void>;
  deleteSetlist: (id: string) => Promise<void>;
  duplicateSetlist: (id: string) => Promise<void>;
  refetch: () => void;
}
```

#### useSetlistDetail Hook
```typescript
// /hooks/useSetlistDetail.ts
interface UseSetlistDetailReturn {
  // State
  setlist: Setlist | null;
  isLoading: boolean;
  error: string | null;
  
  // Actions
  updateSetlistInfo: (data: SetlistUpdateRequest) => Promise<void>;
  refetch: () => void;
}
```

#### useSetlistItems Hook
```typescript
// /hooks/useSetlistItems.ts
interface UseSetlistItemsReturn {
  // State
  items: SetlistItem[];
  isLoading: boolean;
  error: string | null;
  
  // Actions
  addItem: (scoreId: string) => Promise<void>;
  removeItem: (itemId: string) => Promise<void>;
  reorderItems: (newOrder: string[]) => Promise<void>;
  refetch: () => void;
}
```

---

## 2. 타입 정의 우선순위

### 2.1 현재 계획의 누락사항

문서 034에서는 타입 정의가 언급되지 않았으나, 이는 모든 구현의 기반이 되어야 합니다.

### 2.2 타입 정의 우선 구현

**파일**: `/types/setlist.ts`

```typescript
// 기본 Setlist 타입
export interface Setlist {
  id: string;
  title: string;
  description?: string;
  created_at: string;
  updated_at: string;
  user: string;
  items_count: number;
  total_duration?: number;
}

// SetlistItem 타입
export interface SetlistItem {
  id: string;
  setlist: string;
  score: string;  // Score ID
  order_index: number;
  notes?: string;
  
  // 조인된 Score 정보 (상세 조회 시)
  score_details?: {
    title: string;
    composer?: string;
    duration_minutes?: number;
    file_url: string;
    thumbnail_url?: string;
  };
}

// API 요청/응답 타입
export interface SetlistCreateRequest {
  title: string;
  description?: string;
}

export interface SetlistUpdateRequest {
  title?: string;
  description?: string;
}

export interface SetlistItemCreateRequest {
  score_id: string;
  notes?: string;
}

export interface SetlistItemReorderRequest {
  item_orders: Array<{
    item_id: string;
    order_index: number;
  }>;
}
```

---

## 3. UX 일관성 및 Phase 4와의 조율

### 3.1 문제점 지적

**문서 034의 모순**:
- Step 4에서 "Optimistic Update 적용"을 언급
- 하지만 문서 033에서는 Optimistic Updates를 Phase 4로 분류

### 3.2 UX 일관성 방안

**Phase 2에서 구현할 UX**:
```typescript
// 기본적인 로딩 상태 관리 (Phase 2)
const reorderMutation = useMutation({
  mutationFn: reorderItems,
  onMutate: () => setIsReordering(true),
  onSettled: () => setIsReordering(false),
  onError: (error) => {
    // 에러 시 이전 상태로 복원
    showError('순서 변경에 실패했습니다.');
  }
});

// Optimistic Update는 Phase 4에서 구현
// 현재는 로딩 인디케이터와 에러 처리에 집중
```

**Phase 2의 UX 원칙**:
- 명확한 로딩 상태 표시
- 일관된 에러 메시지
- 사용자 행동에 대한 즉시 피드백 (버튼 비활성화 등)
- 복잡한 최적화는 Phase 4로 연기

---

## 4. 백엔드 API 확인 및 검증

### 4.1 API 엔드포인트 확인 필요

문서 034에서 가정한 API가 실제 백엔드와 일치하는지 확인:

```bash
# 확인해야 할 엔드포인트들
GET    /api/v1/setlists/                    # 목록 조회
POST   /api/v1/setlists/                    # 생성
GET    /api/v1/setlists/{id}/               # 상세 조회
PUT    /api/v1/setlists/{id}/               # 수정
DELETE /api/v1/setlists/{id}/               # 삭제
POST   /api/v1/setlists/{id}/duplicate/     # 복제
POST   /api/v1/setlists/{id}/items/         # 아이템 추가
DELETE /api/v1/setlists/{id}/items/{item_id}/  # 아이템 삭제
PUT    /api/v1/setlists/{id}/items/reorder/ # 순서 변경
```

### 4.2 API 검증 방법

```bash
# Django 백엔드에서 URL 패턴 확인
cd backend
python manage.py show_urls | grep setlist

# 또는 Swagger/OpenAPI 문서 확인
curl http://localhost:8000/api/schema/
```

---

## 5. 수정된 구현 순서

### 5.1 기존 계획 (문서 034)
1. Custom Hooks 생성
2. 목록 페이지 UI
3. 상세 페이지 UI  
4. 드래그앤드롭 기능

### 5.2 개선된 구현 순서

**Phase 2.0: 기반 작업**
1. ✅ **타입 정의** (`/types/setlist.ts`)
2. ✅ **백엔드 API 확인** 및 테스트
3. ✅ **API 클라이언트 메서드** 추가 (`/lib/api.ts`)

**Phase 2.1: 세트리스트 목록 기능**
4. ✅ **useSetlists Hook** 구현
5. ✅ **목록 페이지** (`/app/setlists/page.tsx`) UI 구현
6. ✅ **CRUD 기능** 테스트 및 검증

**Phase 2.2: 세트리스트 상세 기능**
7. ✅ **useSetlistDetail Hook** 구현
8. ✅ **useSetlistItems Hook** 구현  
9. ✅ **useScoreLibrary Hook** 구현
10. ✅ **상세 페이지** (`/app/setlists/[id]/page.tsx`) UI 구현

**Phase 2.3: 고급 기능**
11. ✅ **@dnd-kit 설치** 및 설정
12. ✅ **드래그앤드롭** 순서 변경 구현
13. ✅ **전체 기능 통합 테스트**

---

## 6. 기술 스택 보완사항

### 6.1 추가 설치 필요한 패키지

```bash
# 드래그앤드롭
npm install @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities

# 유틸리티 (필요 시)
npm install react-select  # 악보 선택 드롭다운용
npm install react-modal   # 모달 컴포넌트용 (또는 기존 UI 컴포넌트 활용)
```

### 6.2 컴포넌트 재사용 계획

**기존 컴포넌트 활용**:
- `Button` - 모든 액션 버튼
- `LoadingSpinner` - 로딩 상태 표시
- `Modal` - 생성/수정/삭제 확인 모달 (없다면 신규 생성)

**신규 컴포넌트 필요**:
- `SetlistCard` - 세트리스트 목록 아이템
- `SetlistItemCard` - 세트리스트 내 악보 아이템
- `DraggableItem` - 드래그 가능한 아이템 래퍼

---

## 7. 다음 단계 실행 계획

### 즉시 시작 가능한 작업

1. **타입 정의 생성** (`/types/setlist.ts`)
2. **백엔드 API 엔드포인트 확인**
3. **useSetlists Hook 구현** 시작

### 주의사항

- Phase 1에서 확립한 아키텍처 패턴 준수
- 각 Hook은 단일 책임 원칙 적용
- UX 최적화는 Phase 4로 연기하되, 기본적인 사용성은 확보
- 모든 새로운 기능에 대해 에러 처리 및 로딩 상태 관리 필수

---

## 결론

문서 034의 기본 방향성은 올바르나, Hook 아키텍처의 세분화, 타입 정의 우선순위, UX 일관성 측면에서 개선이 필요합니다. 제안된 개선사항을 적용하면 Phase 1에서 확립한 아키텍처 품질을 유지하면서도 세트리스트 기능의 복잡성을 효과적으로 관리할 수 있을 것입니다.

**핵심 개선사항**:
1. Hook 책임 분리 (useSetlists, useSetlistDetail, useSetlistItems, useScoreLibrary)
2. 타입 정의 우선 구현
3. 백엔드 API 확인 및 검증
4. UX 최적화는 Phase 4로 연기하되 기본 사용성 확보

---

**다음 문서**: Phase 2.0 타입 정의 및 API 확인 작업 시작