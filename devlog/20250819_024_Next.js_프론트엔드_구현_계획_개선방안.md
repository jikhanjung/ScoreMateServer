# Next.js 프론트엔드 구현 계획 개선방안

**작성일**: 2025-08-19  
**목적**: [20250819_023_Next.js_프론트엔드_핵심_기능_구현_계획.md](./20250819_023_Next.js_프론트엔드_핵심_기능_구현_계획.md) 검토 및 실무적 개선방안 제시  
**상태**: ✅ 개선된 실행 계획 완성

---

## 📋 **기존 계획 평가**

### ✅ **잘 설계된 부분들**
1. **명확한 우선순위**: Dashboard → Score Library → Setlist Manager → File Upload
2. **API 연계성**: Phase 2.3 백엔드 API와 완벽한 매칭
3. **현실적인 기술 스택**: 이미 설치된 라이브러리 활용
4. **기능 중심 접근**: 사용자 중심의 기능 정의

### ⚠️ **개선이 필요한 부분들**

#### 1. **구현 단계의 세분화 부족**
- 각 기능이 너무 큰 단위로 정의됨
- 개발 진행 상황 추적의 어려움
- 병렬 개발 가능성 부족

#### 2. **기술적 기반 작업 누락**
- API 클라이언트 설정
- 타입 정의 전략
- 에러 처리 시스템
- 글로벌 상태 관리

#### 3. **라우팅 및 네비게이션 구조 미정의**
- URL 구조 불명확
- 페이지 간 이동 흐름 미정의
- 인증 보호 라우트 전략 부재

---

## 💡 **개선된 구현 계획**

### **Phase 0: 기술적 기반 구축 (새로 추가)**

#### **0-1. 프로젝트 기반 설정**
```typescript
// 작업 목록
- 디렉토리 구조 정의
- TypeScript 설정 최적화
- ESLint/Prettier 설정
- 절대 경로 import 설정 (@/ alias)
```

#### **0-2. API 클라이언트 구축**
```typescript
// lib/api.ts
import axios from 'axios';

const api = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
  timeout: 10000,
});

// Request interceptor: JWT 토큰 자동 추가
api.interceptors.request.use((config) => {
  const token = localStorage.getItem('access_token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// Response interceptor: 에러 처리
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // 토큰 만료 시 로그인 페이지로 리다이렉트
      window.location.href = '/auth/login';
    }
    return Promise.reject(error);
  }
);
```

#### **0-3. TypeScript 타입 정의**
```typescript
// types/api.ts
export interface User {
  id: number;
  username: string;
  email: string;
  first_name?: string;
  last_name?: string;
}

export interface Score {
  id: number;
  title: string;
  composer: string;
  tags: string[];
  size_bytes: number;
  page_count?: number;
  has_thumbnail: boolean;
  created_at: string;
  updated_at: string;
  file_url?: string;
}

export interface DashboardData {
  total_scores: number;
  total_setlists: number;
  quota_used_mb: number;
  quota_total_mb: number;
  quota_percentage: number;
  recent_scores: Score[];
  recent_setlists: Setlist[];
  weekly_activity: {
    scores_added: number;
    setlists_created: number;
  };
  quota_recommendations: string[];
}

export interface Setlist {
  id: number;
  name: string;
  description?: string;
  items: SetlistItem[];
  created_at: string;
  updated_at: string;
  total_items: number;
}

export interface SetlistItem {
  id: number;
  score: Score;
  order_index: number;
  notes?: string;
}

// API 응답 래퍼 타입
export interface ApiResponse<T> {
  success: boolean;
  data: T;
  message?: string;
}

export interface PaginatedResponse<T> {
  count: number;
  next: string | null;
  previous: string | null;
  results: T[];
}
```

#### **0-4. 글로벌 상태 관리**
```typescript
// contexts/AuthContext.tsx
'use client';
import { createContext, useContext, useEffect, useState } from 'react';

interface AuthContextType {
  user: User | null;
  token: string | null;
  login: (token: string, user: User) => void;
  logout: () => void;
  isLoading: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [token, setToken] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // 초기 로드 시 토큰 확인
    const storedToken = localStorage.getItem('access_token');
    const storedUser = localStorage.getItem('user');
    
    if (storedToken && storedUser) {
      setToken(storedToken);
      setUser(JSON.parse(storedUser));
    }
    setIsLoading(false);
  }, []);

  const login = (newToken: string, newUser: User) => {
    localStorage.setItem('access_token', newToken);
    localStorage.setItem('user', JSON.stringify(newUser));
    setToken(newToken);
    setUser(newUser);
  };

  const logout = () => {
    localStorage.removeItem('access_token');
    localStorage.removeItem('user');
    setToken(null);
    setUser(null);
  };

  return (
    <AuthContext.Provider value={{ user, token, login, logout, isLoading }}>
      {children}
    </AuthContext.Provider>
  );
}

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};
```

#### **0-5. 라우팅 구조 정의**
```
app/
├── layout.tsx                 # 루트 레이아웃
├── page.tsx                   # 홈페이지 (→ /dashboard 리다이렉트)
├── loading.tsx                # 글로벌 로딩 UI
├── error.tsx                  # 글로벌 에러 UI
├── not-found.tsx             # 404 페이지
│
├── auth/
│   ├── login/
│   │   └── page.tsx          # 로그인 페이지
│   └── register/
│       └── page.tsx          # 회원가입 페이지
│
├── dashboard/
│   └── page.tsx              # 대시보드
│
├── scores/
│   ├── page.tsx              # 악보 목록
│   └── [id]/
│       └── page.tsx          # 악보 상세
│
├── setlists/
│   ├── page.tsx              # 세트리스트 목록
│   ├── new/
│   │   └── page.tsx          # 새 세트리스트 생성
│   └── [id]/
│       ├── page.tsx          # 세트리스트 상세
│       └── edit/
│           └── page.tsx      # 세트리스트 편집
│
└── upload/
    └── page.tsx              # 파일 업로드
```

#### **0-6. 공통 컴포넌트 기반**
```typescript
// components/ui/Layout.tsx
export function Layout({ children }: { children: React.ReactNode }) {
  return (
    <div className="min-h-screen bg-gray-50">
      <Header />
      <main className="container mx-auto px-4 py-8">
        {children}
      </main>
      <Footer />
    </div>
  );
}

// components/ui/LoadingSpinner.tsx
export function LoadingSpinner({ size = 'md' }: { size?: 'sm' | 'md' | 'lg' }) {
  const sizeClasses = {
    sm: 'h-4 w-4',
    md: 'h-8 w-8', 
    lg: 'h-12 w-12'
  };
  
  return (
    <div className={`animate-spin rounded-full border-2 border-gray-300 border-t-blue-600 ${sizeClasses[size]}`} />
  );
}

// components/ui/ErrorBoundary.tsx
'use client';
import { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      return (
        <div className="min-h-screen flex items-center justify-center">
          <div className="text-center">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">
              문제가 발생했습니다
            </h2>
            <p className="text-gray-600 mb-4">
              페이지를 새로고침하거나 잠시 후 다시 시도해주세요.
            </p>
            <button
              onClick={() => window.location.reload()}
              className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700"
            >
              새로고침
            </button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}
```

---

### **개선된 Phase 1: Dashboard (세분화)**

#### **1-1. 기본 레이아웃 및 통계 카드**
```typescript
// 목표: 대시보드 기본 구조 및 핵심 통계 표시
// 예상 소요 시간: 1-2일

// 구현 내용:
- 대시보드 페이지 레이아웃 구성
- 통계 카드 컴포넌트 (총 악보 수, 세트리스트 수, 쿼터 사용량)
- API 연동: GET /api/v1/dashboard/
- 로딩/에러 상태 처리
```

#### **1-2. 쿼터 시각화 차트**
```typescript
// 목표: 쿼터 사용량을 시각적으로 표현
// 예상 소요 시간: 1일

// 구현 내용:
- recharts를 이용한 도넛 차트 또는 프로그레스 바
- 쿼터 임박 시 경고 표시
- 쿼터 상세 정보 툴팁
```

#### **1-3. 최근 활동 및 추천 시스템**
```typescript
// 목표: 사용자 활동 피드 및 시스템 권장사항
// 예상 소요 시간: 1-2일

// 구현 내용:
- 최근 추가된 악보/세트리스트 목록
- 주간 활동 요약
- 쿼터 관련 권장사항 카드
```

### **개선된 Phase 2: Score Library (세분화)**

#### **2-1. 기본 악보 목록 및 페이지네이션**
```typescript
// 목표: 악보 목록의 기본 표시 및 페이지 처리
// 예상 소요 시간: 2일

// 구현 내용:
- 악보 카드 컴포넌트 디자인
- 페이지네이션 구현
- 기본 로딩/에러 상태
- 반응형 그리드 레이아웃
```

#### **2-2. 검색 및 기본 필터링**
```typescript
// 목표: 텍스트 검색 및 기본 필터 구현
// 예상 소요 시간: 2일

// 구현 내용:
- 검색바 컴포넌트
- 태그 필터 (다중 선택)
- URL 상태 동기화
- 검색 결과 하이라이팅
```

#### **2-3. 고급 필터링 및 정렬**
```typescript
// 목표: 복합 필터 및 정렬 옵션 완성
// 예상 소요 시간: 2-3일

// 구현 내용:
- 파일 크기, 페이지 수 범위 슬라이더
- 날짜 범위 선택기
- 정렬 드롭다운 (제목, 작곡가, 크기, 날짜 등)
- 필터 상태 저장/복원
```

#### **2-4. 악보 상세 페이지**
```typescript
// 목표: 개별 악보의 상세 정보 및 액션
// 예상 소요 시간: 1-2일

// 구현 내용:
- 악보 메타데이터 표시
- 썸네일 이미지 (있는 경우)
- 다운로드 버튼
- 세트리스트에 추가 버튼
- 편집/삭제 액션
```

### **개선된 Phase 3: Setlist Manager (세분화)**

#### **3-1. 세트리스트 목록 및 CRUD**
```typescript
// 목표: 기본적인 세트리스트 관리 기능
// 예상 소요 시간: 2일

// 구현 내용:
- 세트리스트 카드 레이아웃
- 생성/수정/삭제 모달
- 폼 유효성 검사
- 옵티미스틱 업데이트
```

#### **3-2. 세트리스트 상세 및 악보 추가**
```typescript
// 목표: 세트리스트 내용 관리
// 예상 소요 시간: 2-3일

// 구현 내용:
- 세트리스트 내 악보 목록
- 악보 검색 및 추가 모달
- 악보 제거 기능
- 실시간 업데이트
```

#### **3-3. 드래그앤드롭 재정렬**
```typescript
// 목표: 직관적인 순서 변경 인터페이스
// 예상 소요 시간: 2-3일

// 구현 내용:
- @dnd-kit/sortable 구현
- 드래그 미리보기
- 순서 변경 API 연동
- 모바일 터치 지원
```

#### **3-4. 세트리스트 고급 기능**
```typescript
// 목표: 복사, 공유 등 부가 기능
// 예상 소요 시간: 1-2일

// 구현 내용:
- 세트리스트 복사
- 세트리스트 공유 URL (선택사항)
- 일괄 액션 (선택 항목 제거 등)
```

### **개선된 Phase 4: File Upload (세분화)**

#### **4-1. 기본 파일 업로드 UI**
```typescript
// 목표: 기본적인 파일 업로드 인터페이스
// 예상 소요 시간: 2일

// 구현 내용:
- 파일 선택 인터페이스
- 드래그앤드롭 존
- 파일 미리보기 (이름, 크기, 타입)
- 기본 유효성 검사
```

#### **4-2. 업로드 진행 상태 및 에러 처리**
```typescript
// 목표: 사용자 피드백 및 에러 처리
// 예상 소요 시간: 2일

// 구현 내용:
- 프로그레스 바
- 업로드 취소 기능
- 에러 메시지 표시
- 재시도 메커니즘
```

#### **4-3. 메타데이터 입력 및 완료 처리**
```typescript
// 목표: 업로드 후 메타데이터 관리
// 예상 소요 시간: 1-2일

// 구현 내용:
- 제목, 작곡가, 태그 입력 폼
- 자동 메타데이터 추출 (가능한 경우)
- 업로드 완료 후 리다이렉트
- 성공 알림 토스트
```

---

## 🛠️ **추가 기술적 개선사항**

### **1. 에러 처리 전략**

#### **토스트 알림 시스템**
```typescript
// lib/toast.ts
import { toast } from 'react-hot-toast';

export const showSuccess = (message: string) => {
  toast.success(message, {
    duration: 4000,
    position: 'top-right',
  });
};

export const showError = (message: string) => {
  toast.error(message, {
    duration: 6000,
    position: 'top-right',
  });
};

export const showLoading = (message: string) => {
  return toast.loading(message, {
    position: 'top-right',
  });
};
```

#### **API 에러 처리 표준화**
```typescript
// lib/api-error.ts
export class ApiError extends Error {
  constructor(
    public status: number,
    public message: string,
    public details?: any
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

export const handleApiError = (error: any): string => {
  if (error instanceof ApiError) {
    return error.message;
  }
  
  if (error.response?.data?.message) {
    return error.response.data.message;
  }
  
  if (error.message) {
    return error.message;
  }
  
  return '알 수 없는 오류가 발생했습니다.';
};
```

### **2. 성능 최적화**

#### **이미지 최적화**
```typescript
// components/ui/OptimizedImage.tsx
import Image from 'next/image';
import { useState } from 'react';

interface OptimizedImageProps {
  src: string;
  alt: string;
  width: number;
  height: number;
  className?: string;
}

export function OptimizedImage({ src, alt, width, height, className }: OptimizedImageProps) {
  const [isLoading, setIsLoading] = useState(true);
  const [hasError, setHasError] = useState(false);

  if (hasError) {
    return (
      <div className={`bg-gray-200 flex items-center justify-center ${className}`}>
        <span className="text-gray-500">이미지 로드 실패</span>
      </div>
    );
  }

  return (
    <div className={`relative ${className}`}>
      {isLoading && (
        <div className="absolute inset-0 bg-gray-200 animate-pulse" />
      )}
      <Image
        src={src}
        alt={alt}
        width={width}
        height={height}
        onLoadingComplete={() => setIsLoading(false)}
        onError={() => setHasError(true)}
        className={`transition-opacity duration-200 ${
          isLoading ? 'opacity-0' : 'opacity-100'
        }`}
      />
    </div>
  );
}
```

#### **무한 스크롤 (옵션)**
```typescript
// hooks/useInfiniteScroll.ts
import { useInfiniteQuery } from '@tanstack/react-query';
import { useEffect } from 'react';
import { useIntersection } from '@mantine/hooks';

interface UseInfiniteScrollOptions<T> {
  queryKey: string[];
  queryFn: (page: number) => Promise<PaginatedResponse<T>>;
  enabled?: boolean;
}

export function useInfiniteScroll<T>({ 
  queryKey, 
  queryFn, 
  enabled = true 
}: UseInfiniteScrollOptions<T>) {
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
    isLoading,
    error,
  } = useInfiniteQuery({
    queryKey,
    queryFn: ({ pageParam = 1 }) => queryFn(pageParam),
    getNextPageParam: (lastPage, pages) => {
      return lastPage.next ? pages.length + 1 : undefined;
    },
    enabled,
  });

  const { ref, entry } = useIntersection({
    threshold: 1,
  });

  useEffect(() => {
    if (entry?.isIntersecting && hasNextPage && !isFetchingNextPage) {
      fetchNextPage();
    }
  }, [entry, fetchNextPage, hasNextPage, isFetchingNextPage]);

  const items = data?.pages.flatMap(page => page.results) ?? [];

  return {
    items,
    isLoading,
    error,
    isFetchingNextPage,
    loadMoreRef: ref,
    hasNextPage,
  };
}
```

### **3. 접근성 및 SEO**

#### **메타데이터 설정**
```typescript
// app/dashboard/page.tsx
import { Metadata } from 'next';

export const metadata: Metadata = {
  title: '대시보드 | ScoreMate',
  description: '악보 라이브러리 현황과 쿼터 사용량을 한눈에 확인하세요.',
};

export default function DashboardPage() {
  // ...
}
```

#### **키보드 네비게이션**
```typescript
// hooks/useKeyboardNavigation.ts
import { useEffect } from 'react';

export function useKeyboardNavigation(
  items: any[],
  selectedIndex: number,
  onSelect: (index: number) => void,
  onEnter?: (item: any) => void
) {
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      switch (event.key) {
        case 'ArrowDown':
          event.preventDefault();
          onSelect(Math.min(selectedIndex + 1, items.length - 1));
          break;
        case 'ArrowUp':
          event.preventDefault();
          onSelect(Math.max(selectedIndex - 1, 0));
          break;
        case 'Enter':
          if (onEnter && items[selectedIndex]) {
            event.preventDefault();
            onEnter(items[selectedIndex]);
          }
          break;
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [items, selectedIndex, onSelect, onEnter]);
}
```

---

## 📊 **개선된 개발 일정 예상**

### **전체 일정: 3-4주**

| Phase | 기능 | 예상 소요 | 우선도 |
|-------|------|-----------|--------|
| **Phase 0** | 기술적 기반 구축 | 3-4일 | 🔥 필수 |
| **Phase 1-1** | Dashboard 기본 | 1-2일 | 🔥 필수 |
| **Phase 1-2** | Dashboard 차트 | 1일 | ⭐ 권장 |
| **Phase 1-3** | Dashboard 고급 | 1-2일 | ⭐ 권장 |
| **Phase 2-1** | 악보 목록 기본 | 2일 | 🔥 필수 |
| **Phase 2-2** | 검색/기본 필터 | 2일 | 🔥 필수 |
| **Phase 2-3** | 고급 필터/정렬 | 2-3일 | ⭐ 권장 |
| **Phase 2-4** | 악보 상세 페이지 | 1-2일 | ⭐ 권장 |
| **Phase 3-1** | 세트리스트 CRUD | 2일 | 🔥 필수 |
| **Phase 3-2** | 악보 추가/제거 | 2-3일 | 🔥 필수 |
| **Phase 3-3** | 드래그앤드롭 | 2-3일 | ⭐ 권장 |
| **Phase 3-4** | 세트리스트 고급 | 1-2일 | 📌 선택 |
| **Phase 4-1** | 업로드 UI 기본 | 2일 | 🔥 필수 |
| **Phase 4-2** | 진행상태/에러 | 2일 | ⭐ 권장 |
| **Phase 4-3** | 메타데이터 입력 | 1-2일 | ⭐ 권장 |

### **MVP (최소 기능 제품) - 2주**
- Phase 0 (기반 구축)
- Phase 1-1 (기본 대시보드)
- Phase 2-1, 2-2 (기본 악보 관리)
- Phase 3-1, 3-2 (기본 세트리스트)
- Phase 4-1 (기본 업로드)

### **Full Feature - 3-4주**
- 모든 Phase 포함
- 추가 최적화 및 테스트

---

## 🎯 **실행 권장사항**

### **1. 개발 순서**
```
1주차: Phase 0 + Phase 1 (기반 + 대시보드)
2주차: Phase 2 (악보 라이브러리)
3주차: Phase 3 (세트리스트 관리)
4주차: Phase 4 (파일 업로드) + 최적화
```

### **2. 병렬 개발 가능 영역**
- UI 컴포넌트와 API 통신 로직
- 각 페이지의 독립적 기능들
- 공통 컴포넌트와 페이지별 기능

### **3. 테스트 전략**
```typescript
// 단위 테스트: 개별 컴포넌트 및 훅
// 통합 테스트: API 통신 및 상태 관리
// E2E 테스트: 주요 사용자 플로우
```

---

## 🚀 **다음 단계**

### **즉시 시작할 수 있는 작업**
1. **Phase 0 실행**: 프로젝트 기반 구축 (3-4일)
2. **디자인 시스템**: Tailwind 커스텀 설정 및 컴포넌트 라이브러리
3. **API 목 데이터**: 개발 중 사용할 테스트 데이터 준비

### **백엔드 연동 준비**
1. **CORS 설정 확인**: 로컬 개발 환경에서의 API 접근
2. **API 문서화**: 프론트엔드 팀을 위한 API 명세서
3. **에러 응답 표준화**: 일관된 에러 메시지 형식

---

**결론**: 이 개선된 계획을 통해 **체계적이고 단계적인 프론트엔드 개발**이 가능하며, **2주 내 MVP, 4주 내 완전한 기능**을 구현할 수 있을 것으로 예상됩니다.

---

**다음 문서**: Next.js 프론트엔드 Phase 0 구현 시작  
**참고 문서**: [원본 계획서](./20250819_023_Next.js_프론트엔드_핵심_기능_구현_계획.md)